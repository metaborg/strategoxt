/**
 * Translating high-level constructs to low-level ones.
 *
 * @author Eelco Visser 1998 - 2004
 */

module desugar

imports 
  Stratego-Sugar
  stratego/strc/lib/stratlib
  stratego/strc/front/DefaultStrat

strategies // Desugaring Strategie

  desugar-top =
    Specification([id,id,Strategies(desugar-spec)])

  /**
   * Desugar all definitions in specification
   *
   * Note that inline bodies of external definitions are _not_
   * desugared. These are assumed to be in StrategoCore. This should
   * be checked.
   */

  desugar-spec = 
    map(
      SDef(id, id, desugar) 
      + SDefT(id, id, id, desugar)
      + ExtSDef(id, id, id)
      + ExtSDefInl(id, id, id, id)
      <+ debug(!"not a definition: "); fail
    )

strategies // Desugaring Strategies

  pre-desugar =
    topdown(repeat(Desugar); try(DesugarOnce))

  stratego-desugar =
    topdown(repeat(Desugar))

  desugar = 
    topdown(
      try(desugarRule)
      ; repeat(
          LiftPrimArgs
	  <+ LiftCallArgs 
	  <+ LiftTopLevelBuildApp
	  <+ LiftBuildApps
	  <+ LiftTopLevelMatchApp
	  <+ LiftMatchApps 
	  <+ Desugar
        )
    )

rules // Lift non-variable arguments to primitives.

  LiftPrimArgs : 
    Prim(f, ts) -> Scope(xs, Seq(<seqs>s, PrimT(f, [], ts')))
    where <fetch(not(Var(id)))> ts
        ; <unzip(LiftPrimArg); (concat, unzip(id))> ts => (xs, (s, ts'))

  LiftPrimArgs : 
    PrimT(f, ss, ts) -> Scope(xs, Seq(<seqs>s, PrimT(f, ss, ts')))
    where <fetch(not(Var(id)))> ts
        ; <unzip(LiftPrimArg); (concat, unzip(id))> ts => (xs, (s, ts'))

  LiftCallArgs : 
    CallT(f, ss, ts) -> Scope(xs, Seq(<seqs>s, CallT(f, ss, ts')))
    where <fetch(not(Var(id)))> ts
        ; <unzip(LiftPrimArg); (concat, unzip(id))> ts => (xs, (s, ts'))

  LiftCallArgs :
    CallDynamic(t, ss, ts) -> Scope(xs, Seq(<seqs>s, CallDynamic(t', ss, ts')))
      where 
        <fetch(not(Var(id)))> [t|ts] 
      ; <unzip(LiftPrimArg);(concat, unzip(id))> [t|ts] => (xs, (s, [t'|ts']))

  LiftPrimArg :
    Var(x) -> ([], (Id, Var(x)))

  LiftPrimArg :
    t -> ([x], (Where(Seq(Build(t), Match(Var(x)))), Var(x)))
    where <not(Var(id))> t; new => x


/*
 Strategy Applications

	Factoring out strategy applications; The right-hand side of a
	rule can contain applications of a strategy to a term; This is
	factored out by translating it to a condition that applies the
	strategy and matches the result against a new variable, which
	is then used in the rhs;  In fact this can be generalized to
	applications in arbitrary builds;

*/

rules

  LiftTopLevelBuildApp :
    |[ !<s> t ]| -> |[ !t; s ]|

  LiftBuildApps : 
    |[ !t ]| -> s
    where {| AddApp
	   : <sometd(LiftBuildApp)> t => t'
	   ; <repeat(once-AddApp)> |[ !t' ]| => s
	   |}

  LiftBuildApp :
    Term|[ <s> t ]| -> Term|[ x ]|
    where new => x
        ; rules( AddApp :+ s' -> |[ {x : where(<s> t => x); s'} ]| )

  LiftBuildApp :
    Term|[ <s> ]| -> Term|[ x ]|
    where new => x
        ; rules( AddApp :+ s' -> |[ {x : where(s => x); s'} ]| )

  LiftTopLevelMatchApp :
    |[ ?<s> t ]| -> |[ s; ?t ]|

  LiftMatchApps : 
    |[ ?t ]| -> s
    where {| AddApp
	   : <sometd(LiftMatchApp)> t => t'
	   ; <repeat(once-AddApp)> |[ ?t' ]| => s
	   |}

  LiftMatchApp :
    Term|[ <s> t ]| -> Term|[ x ]|
    where new => x
        ; rules( AddApp :+ s' -> |[ {x : s'; !x; !t; s} ]| )

  LiftMatchApp :
    Term|[ <s> ]| -> Term|[ x ]|
    where new => x
        ; rules( AddApp :+ s' -> |[ {x : s'; !x; s} ]| )

strategies

/*
 Rules to Strategies

	A rule corresponds to a strategy that first matches the
	left-hand side, then checks the conditions and finally builds
	the right-hand side; The left-hand side and right-hand side
	should be in basic term format, as defined by the predicate
	|bterm|;
 */

  pureterm = not(topdown(Con(id, id, id) + App(id, id)))

  buildterm = not(topdown(Con(id, id, id) + Wld))

rules

  RtoS : |[ (t1 -> t2 where s) ]| -> |[ ?t1; where(s); !t2 ]|
         where <pureterm> t1 ; <buildterm> t2

strategies // Desugaring single rules

  desugarRule = 
    rec x(try(Scope(id, x) + RtoS))

signature
  constructors
    Con       : Var * Term * SVar   -> Term
    TupleCong : List(Strategy) -> Strategy
    TupleCong : Strategy


rules

  Desugar : 
    Strat|[ <s> t ]| -> |[ !t; s ]| 

  Desugar : 
    |[ s => t ]| -> |[ s; ?t ]|

//  Desugar :
//   |[ t1 := t2 ]| -> |[ !t2; ?t1 ]|

  Desugar :
    Assign(t1, t2) -> Seq(Build(t2), Match(t1))

// rules

  Desugar :
    RDefNoArgs(f, r) -> RDefT(f, [], [], r)

  Desugar :
    RDef(f, xs, r) -> RDefT(f, xs, [], r)

// dynamic rules

  Desugar :
    RDecNoArgs(f) -> RDec(f, [])

  Desugar :
    RDec(f, ss) -> RDecT(f, ss, [])

  Desugar :
    DynRuleIntersectFix(rulenames, s) -> 
    CallT(SVar("dr-fix-and-intersect"), [s], [<mk-rulenames> rulenames])

  Desugar :
    DynRuleIntersect(s1, rulenames, s2) -> 
    CallT(SVar("dr-fork-and-intersect"), [s1, s2], [<mk-rulenames> rulenames])

  Desugar :
    DynRuleUnionFix(rulenames, s) -> 
    CallT(SVar("dr-fix-and-union"), [s], [<mk-rulenames> rulenames])

  Desugar :
    DynRuleUnion(s1, rulenames, s2) -> 
    CallT(SVar("dr-fork-and-union"), [s1, s2], [<mk-rulenames> rulenames])

  Desugar :
    DynRuleIntersectUnionFix(rulenames1, rulenames2, s) ->
    CallT(SVar("dr-fix-and-intersect-union"), [s], [<mk-rulenames> rulenames1, <mk-rulenames> rulenames2])

  Desugar :
    DynRuleIntersectUnion(s1, rulenames1, rulenames2, s2) ->
    CallT(SVar("dr-fork-and-intersect-union"), [s1, s2], [<mk-rulenames> rulenames1, <mk-rulenames> rulenames2])
		    

  mk-rulenames =
    foldr(!NoAnnoList(Op("Nil",[])), 
          !NoAnnoList(Op("Cons", [<Fst>, <Snd>])), 
          !NoAnnoList(Str(<id>)))
    <+ ?RuleNames(<id>)


// strategy definitions

  Desugar :
    SDefNoArgs(f, s) -> SDefT(f, [], [], s)

  Desugar :
    SDef(f, xs, s) -> SDefT(f, xs, [], s)

// strategy calls

  Desugar :
    CallNoArgs(f) -> CallT(f, [], [])

  Desugar :
    Call(f, ss) -> CallT(f, ss, [])

  DesugarOnce :
    PrimNoArgs(f) -> PrimT(<try(un-double-quote)>f, [], [])

  DesugarOnce :
    Prim(f,ts) -> PrimT(<try(un-double-quote)>f, [], ts)

  DesugarOnce :
    PrimT(f,ss,ts) -> PrimT(<try(un-double-quote)>f, ss, ts)

// sugar for choice

  Desugar :
    |[ s1 +> s2 ]| -> |[ s2 <+ s1 ]|
    // RChoice(s1, s2) -> LChoice(s2, s1)

  Desugar :
    |[ if s1 then s2 else s3 end ]| -> |[ where(s1) < s2 + s3 ]|

  Desugar :
    |[ if s1 then s2 end ]| -> |[ where(s1) < s2 + id ]|

  Desugar :
    SwitchChoiceNoOtherwise(s0, b*) -> SwitchChoice(s0, b*, |[ fail ]|)
    // |[ switch s1 sc* end ]| -> |[ switch s1 sc* otherwise fail end ]|

  Desugar :
    SwitchChoice(s1, sc*, s2) -> |[ {x : where(s1 => x); s} ]|
    // |[ switch s1 sc* s2 end ]| -> |[ {x : where(s1 => x); s} ]|
    where new => x
        ; <foldr(!s2, glchoice(|x))> sc* => s

  glchoice(|x) : 
    ((s1, s2), s3) -> |[ if <~s1> x then ~s2 else ~s3 end ]|

  glchoice(|x) :
    (SwitchCase(s1, s2), s3) -> |[ if <~s1> x then ~s2 else ~s3 end ]|

  Desugar :
    |[ where(s) ]| -> |[ {x: ?x; s; !x} ]|
    where new => x

// overlays

  Desugar :
    OverlayNoArgs(f, t) -> Overlay(f, [], t)

  Desugar :
    RuleNoCond(l, r) 	-> Rule(l, r, Id)

  Desugar :
    ParenStrat(x) -> x

// congruences

  Desugar :
    AnnoCong(s1, StrategyCurly(s2)) -> Call(SVar("Anno_Cong__"), [s1, s2])

  Desugar :
    EmptyTupleCong() -> Call(SVar(""), [])

  Desugar :
    TupleCong([x]) -> x

  Desugar :
    TupleCong(ts) -> Call(SVar(""), ts)
    where <not([id])> ts

  Desugar :
    TupleCong(t,ts) -> Call(SVar(""), [t|ts])

  Desugar :
    ExplodeCong(s1, s2) -> 
    |[ {x, x', y, y': (x#(y) -> x'#(y') where <s1> x => x'; <s2> y => y')} ]|
    where new => x; new => x'; new => y; new => y'

  Desugar :
    ListCongNoTail(ts) -> 
    <foldr(!Call(SVar("Nil"),[]),\ (t1, t2) -> Call(SVar("Cons"),[t1,t2]) \ )> ts

  Desugar :
    ListCong(ts,t) -> 
    <foldr(!t,\ (t1, t2) -> Call(SVar("Cons"),[t1,t2]) \ )> ts

  Desugar :
    StrCong(x) -> Match(NoAnnoList(Str(x)))

  Desugar :
    IntCong(x) -> Match(NoAnnoList(Int(x)))

  Desugar :
    RealCong(x) -> Match(NoAnnoList(Real(x)))

  Desugar :
    CharCong(c) -> Match(NoAnnoList(Char(c)))

  /**
   * A quoted congruence is translated to a strategy call.
   */
  Desugar :
    CongQ(f, ss) -> Call(SVar(<escape> f), ss)

/**
 * Term sugar
 */
rules

  Desugar :
    NoAnnoList(Tuple([t])) -> t

  Desugar :
    AnnoList(Tuple([NoAnnoList(t)]), t*) -> AnnoList(t, t*)

  Desugar :
    AnnoList(Tuple([AnnoList(t, t1*)]), t2*) -> AnnoList(t, t1*)

  Desugar :
    Tuple(ts) -> Op("", ts)
    where <not([id])> ts

  Desugar :
    List([]) -> Op("Nil", [])

  Desugar :
    List([t | ts]) -> 
    Op("Cons", [t, <foldr(!NoAnnoList(Op("Nil",[])), 
			  \ (t1, t2) -> NoAnnoList(Op("Cons",[t1,t2])) \ )> ts])

  Desugar :
    ListTail([],t) -> t

  Desugar :
    ListTail([t1 | ts], t2) -> 
    Op("Cons", [t1, <foldr(!t2,\ (t1, t2) -> NoAnnoList(Op("Cons",[t1,t2])) \ )> ts])

  /**
   * Quoted constructors are translated to ordinary Ops, where the
   * symbol is escaped. So, the symbol "foo" is represented as
   * \"foo\".
   */
  Desugar :
    OpQ(f, ts) -> Op(<escape> f, ts)

// Signatures

  Desugar : 
    SortNoArgs(x) -> Sort(x, [])

  Desugar :
    SortList(xs) -> <foldr(!Sort("Nil",[]), !Sort("Cons",[<Fst>,<Snd>]))> xs

  Desugar :
    SortListTl(xs, y) -> <foldr(!y, !Sort("Cons",[<Fst>,<Snd>]))> xs

  Desugar :
    SortTuple(xs) -> 
    Sort("Tuple", [<foldr(!Sort("Nil",[]), !Sort("Cons",[<Fst>,<Snd>]))> xs])


// Characters

  Desugar :
    Char(c) -> Int(<int-to-string>i)
    where <DesugarChar <+ explode-string; DesugarCharGeneric> c => i

  DesugarCharGeneric :
    [39, i, 39] -> i
  DesugarChar :
    "'\\''" -> 39
  DesugarChar :
    "'\\n'" -> 10
  DesugarChar :
    "'\\t'" -> 9
  DesugarChar : // carriage return
    "'\\r'" -> 13
  DesugarChar : // space
    "'\\ '" -> 32

// note: this should not be done in frontend if already done by pack-stratego
  DesugarOnce : 
    Str(x) -> Str(y)
    where <un-double-quote; unescape> x => y

strategies

  DesugarOnce =
    DefaultVarDec(RemoveLeadingPrime)
    + RDefT(RemoveLeadingPrime,id,id,id)
    + RDef(RemoveLeadingPrime,id,id)
    + SDefT(RemoveLeadingPrime,id,id,id)
    + SDef(RemoveLeadingPrime,id,id)
    + VarDec(RemoveLeadingPrime,id)
    + Var(RemoveLeadingPrime)
    + SVar(RemoveLeadingPrime)
    + OpDecl(RemoveLeadingPrime,id)
    + Op(RemoveLeadingPrime,id)

  RemoveLeadingPrime :
    x -> x'
    where <explode-string> x => [39 | cs]
        ; <implode-string> cs => x'

  DesugarOnce :
    CallDynamic(t1,s*,t*) -> CallDynamic(Term |[ <conc-strings>(<cify>t1,t2) ]|,s*,t*)
    where 
      <length>s* ; int-to-string => i
    ; <length>t* ; int-to-string => j
    ; !NoAnnoList(Str(<concat-strings>["_",i,"_",j])) => t2

/**
 * Translating high-level constructs to low-level ones.
 *
 * @author Eelco Visser 1998 - 2004
 */

rules // varyadic operators

  MkSeq : (s1, s2) -> Seq(s1, s2)

  seqs = foldr(!Id, MkSeq)


rules // variable declarations

  desugar-DefaultVarDec =
    topdown(try(DesugarDefaultVarDec))

  DesugarDefaultVarDec :
    SDefT(f, s1, t1, s) -> SDefT(f, s2, t2, s)
    where <map(try(MkFunType))> s1 => s2
        ; <map(try(MkConstType))> t1 => t2

  DesugarDefaultVarDec :
    ExtSDef(f, s1, t1) -> ExtSDef(f, s2, t2)
    where <map(try(MkFunType))> s1 => s2
        ; <map(try(MkConstType))> t1 => t2

  MkFunType :
    DefaultVarDec(x)-> VarDec(x, DefaultStrat)

  MkConstType :
    DefaultVarDec(x)-> VarDec(x, DefaultTerm)
