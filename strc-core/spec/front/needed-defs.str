/**
 * Extract those definitions that are needed for the main strategy and
 * join the bodies of operators with multiple definitions.
 */

module needed-defs
imports Stratego DefaultStrat desugar stratlib

strategies

  /**
   * Obtaining all definitions
   */
  all-defs = 
    !(<definition-names>, <sort-defs; check-ext-overload>, [])
    ; extract-needed-defs

  /**
   * Obtaining needed definitions
   */
  needed-defs = 
    !( [ ("main", (0,0))
       , ("DYNAMIC-CALLS", (0,0))
       | <external-defs> ]
    , <sort-defs; check-ext-overload>
    , []
    )
  ; extract-needed-defs

  extract-needed-defs =
    graph-nodes-undef-roots-chgr(
      get-definition
      , svars-arity; map(try(DefinitionExists))
      , \ (_,x,d) -> [x|d] \ 
    )
    // FilterNonMissingDefs; 
    ; (NoMissingDefs <+ MissingDefs; <exit> 1)

strategies

  /**
   * Obtain names of all definitions, where name is identifier
   * plus arities.
   */

  definition-names = 
    where( new-iset => s )
  ; map({ t: DefinitionName => t ; <iset-add(|t)>s })
  ; <iset-elements>s 

  DefinitionName :
    |[ f(a1* | a2*) = s ]| -> (f, (<length>a1*, <length>a2*))

  DefinitionName :
    |[ external f(a1* | a2*) ]| -> (f, (<length>a1*, <length>a2*))

  DefinitionName :
    |[ external f(a1* | a2*) = s ]| -> (f, (<length>a1*, <length>a2*))

  is-new-def = 
    ?|[ f(a1* | a2*) = s ]|

  is-external-def =
    ?|[ external f(a1* | a2*) ]|

  is-external-def =
    ?|[ external f(a1* | a2*) = s]|

  external-defs = 
    filter(is-external-def; DefinitionName)

  sdef-key-to-string :
    (f, (s, t)) -> <concat-strings> [f, "/", <int-to-string> s, "-", <int-to-string> t]

strategies

  check-ext-overload =
    let helper =
          DefinitionName
          ; if ExtDefinition then
              sdef-key-to-string
              ; debug(!"error: redefining external definition: ")
              ; <exit> 1
            end
     in map(where(is-new-def < helper + id))
    end

strategies

  /**
   * Sorting definitions
   *
   * Associate with the pair \verb|(f, n)| of strategy name and arity
   * the list of its definitions. The dynamic rule \verb|Definitions|
   * implements this association.
   */

  sort-defs = 
    map(RegisterDef)

  Definitions =
    bagof-Definition

  Arities = 
    bagof-Arity; make-set

  RegisterDef = ?def; 
    where(
       <DefinitionName> def => (f, (n, m))
      ; rules(
          Definition :+ (f, (n, m)) -> def
          Arity      :+ f -> (n, m)
        )
      ; if <is-external-def> def then
          rules(
            ExtDefinition : (f, (n, m)) -> def
          )
        end
    )

strategies

  /**
   * Joining Definitions
   *
   * Join multiple definitions for the same strategy operator into one
   * definition by unifying the list of formal strategy parameters.
   */

  joindefs = 
    JoinDefs1 <+ JoinDefs2 <+ JoinDefsExt

rules

  JoinDefs1 : 
    [sdef] -> sdef

  JoinDefs2 : 
    defs @ [SDefT(f, xs1, xs2, s) | _] -> SDefT(f, ys1, ys2, <choices> ss)
    where <map(VarDec(new,id))> xs1 => ys1
	; <map(VarDec(new,id))> xs2 => ys2
	; <map(\ VarDec(y, t) -> SVar(y) \ )> ys1 => ys1'
	; <map(\ VarDec(y, t) -> Var(y) \ )> ys2 => ys2'
	; <map(RenameDefinition(|ys1', ys2'))> defs => ss

  RenameDefinition(|ys1, ys2) :
    SDefT(_, xs1, xs2, s1) -> s3
    where <map(\ VarDec(x2,_) -> x2 \ )> xs2 => zs2
	; <tsubs> (zs2, ys2, s1) => s2
	; {| RenameSVar :
             <zip({?(VarDec(x1,_), y1)
                   ; rules( RenameSVar : SVar(x1) -> y1 ) }
              )> (xs1, ys1)
	     ; <alltd(RenameSVar)> s2 => s3
          |}

  JoinDefsExt =
    where(map(
      ?ExtSDef(f, <length => i>, <length => j>) 
    + ?ExtSDefInl(f, <length => i>, <length => j>, s)
    ))
    ; (fetch-elem(?ExtSDefInl(_,_,_,_)) <+ Hd)

  JoinDefsExt =
    fetch(?ExtSDef(f,_,_) + ?ExtSDefInl(f,_,_,_))
    ; fetch(?SDefT(f,_,_,_))
    ; <debug(!"error: redefining external definition: ")> f
    ; giving-up

  choices = 
    foldr(!Fail, !Choice(<Fst>,<Snd>))

rules

  /**
   * A strategy operator f with arity n is needed. All definitions for
   * the operator are fetched and joined. Note that this entails
   * that (1) operators can be overloaded and (2) there can be more
   * than one definition of an operator.
   */

  get-definition = 
    OverloadedDef; (joindefs, id)

  DefinitionExists :
    (f, (0,0)) -> (f, (n,m))
    where <Arities> f => [(n,m)]; <Definitions> (f, (n,m))

  DefinitionExists =
    ?(f, (0,0))
    ; <Arities> f => [_,_|_]
    ; not(fetch(?(0,0)))
    ; <error> ["passing name of overloaded definition: ", f]
    ; giving-up

  OverloadedDef :
    ((f, n), defs) -> (<Definitions> (f, n), defs)

/*
  FilterNonMissingDefs :
    (defs, undefs) -> (defs, undefs')
    where <filter(not(Definitions))> undefs => undefs'
*/

  NoMissingDefs : 
    (defs, []) -> defs

  MissingDefs : 
    (defs, [f|fs]) -> defs
    where <map(MissingDef)> [f|fs]

  MissingDef : 
    (f, n) -> <error> ["error: operator ", f, "/", n, " undefined "]

/*

Copyright (C) 1998-2005 Eelco Visser <visser@acm.org>

*/
