module utils

imports

stratego/strc/gradual/signatures
stratego/strc/gradual/main
stratego/strc/gradual/environment
stratego/strc/immutable/map
stratego/strc/immutable/set

strategies

// origin-track-forced
otf(s) = ![<id>]; all(s); ?[<id>]

otf12(s): t1 -> (<otf(!t2)> t1, etc)
  where (t2, etc) := <s> t1

otf22(s): t@(t1, _) -> (<otf(!t2)> t1, etc)
  where (t2, etc) := <s> t

otf21(s): t@(t1, _) -> <otf(!t2)> t1
  where t2 := <s> t

otf31(s): t@(t1, _, _) -> <otf(!t2)> t1
  where t2 := <s> t

otf12-sugar(desugar, s, resugar): t1 -> t4st
  where
    t2 := <otf(desugar)> t1
  ; t3st := <s> t2
  ; t4st := <otf12(resugar)> t3st

otf22-sugar(desugar, s, resugar): t1st -> t4st
  where
    t2st := <(otf(desugar), id)> t1st
  ; t3st := <s> t2st
  ; t4st := <(otf(resugar), id)> t3st

strategies

desugar-SType = otf(\FunNoArgsType(i, o) -> FunTType([], [], <desugar-Type> i, <desugar-Type> o)\)
desugar-SType = otf(\FunType(sargs, i, o) -> FunTType(<map(desugar-SType)> sargs, [], <desugar-Type> i, <desugar-Type> o)\)
desugar-SType = otf(FunTType(map(desugar-SType), map(desugar-Type), desugar-Type, desugar-Type))

desugar-Type = otf(\SortVar("str") -> StringT()\)
desugar-Type = otf(\SortVar("int") -> IntT()\)
desugar-Type = otf(\SortVar("real") -> RealT()\)
desugar-Type = otf(\SortNoArgs(x) -> Sort(x, [])\)
desugar-Type = otf(\SortList(xs) -> <foldr(!Sort("Nil",[]), !Sort("Cons",[<Fst>,<Snd>]))> xs\)
desugar-Type = otf(\SortListTl(xs, y) -> <foldr(!y, !Sort("Cons",[<Fst>,<Snd>]))> xs\)
desugar-Type = otf(\SortTuple(xs) -> TupleT(<map(desugar-Type)> xs)\)
desugar-Type = otf(\TupleT(t1, t2) -> TupleT(<desugar-TupleType>)\)
desugar-Type = id

desugar-TupleType =
  otf(\TupleT(t1, t2) -> [<desugar-Type> t1 | <desugar-TupleType> t2]\)
  <+ otf(![<desugar-Type>])

arityOf-SType: FunTType(st*, tt*, _, _) -> (<length> st*, <length> tt*)

strategies

nameOf-StrategyDef-RuleDef: SDefT(name, s*, t*, _) -> (name{}, <length> s*, <length> t*)
nameOf-StrategyDef-RuleDef: SDef(name, s*, _) -> (name{}, <length> s*, 0)
nameOf-StrategyDef-RuleDef: SDefNoArgs(name, _) -> (name{}, 0, 0)
nameOf-StrategyDef-RuleDef: ExtSDefInl(name, s*, t*, _) -> (name{}, <length> s*, <length> t*)
nameOf-StrategyDef-RuleDef: ExtSDef(name, s*, t*) -> (name{}, <length> s*, <length> t*)

nameOf-StrategyDef-RuleDef: RDefT(name, s*, t*, _) -> (name{}, <length> s*, <length> t*)
nameOf-StrategyDef-RuleDef: RDef(name, s*, _) -> (name{}, <length> s*, 0)
nameOf-StrategyDef-RuleDef: RDefNoArgs(name, _) -> (name{}, 0, 0)

nameOf-DefHasType: DefHasType(name, <desugar-SType>) -> (name{}, <length> s*, <length> t*)
  with ?FunTType(s*, t*, _, _)

strategies

// This is the mapping from the directed consistency rule (t ~> t) to coercions (t ~> t : c)
computeCoercion(|lvl, from, to): subj -> <computeCoercion(|subj)> (lvl, from, to)
computeCoercion(|from, to): subj -> <computeCoercion(|subj)> (MTError(), from, to)

// computeCoercion :: Type * Type -> Coercion
computeCoercion: (from, to) -> <computeCoercion(|from)> (MTError(), from, to)

// computeCoercion :: MessageType * Type * Type -> Coercion
computeCoercion(|subj): (_, from, DynT(to)) -> Id(){t}
  where
    if not(DynT(f) := from; (Dyn() := f <+ <CanCoerce> (f, to)) <+ Dyn() := to <+ not(DynT() := from); <CanCoerce> (from, to))
      then <report-Warn> (subj, NoInjectionBetween(from, DynT(to)))
    end
  ; if not(DynT() := from)
      then t := from
      else if DynT(f) := from; <CanCoerce> (f, to)
        then t := DynT(f)
        else t := DynT(to)
      end
    end
computeCoercion(|subj): (MTError(), DynT(), to) -> RuntimeCheck(to){to}
computeCoercion(|subj): (_, DynT(from), to) -> Id(){to}
  where
    if not(Dyn() := from <+ <CanCoerce> (from, to))
      then <report-Warn> (subj, NoInjectionBetween(from, to))
    end
computeCoercion(|subj): (lvl, from, to) -> coercion
  where if <CanCoerce> (from, to)
    then coercion := Id(){from}
    else <report> (lvl, subj, NoInjectionBetween(from, to))
       ; if MTError() := lvl
           then coercion := Fail(){FailT()}
           else coercion := Id(){to}
         end
  end

// computeSCoercion :: (|SType, SType) ? -> SCoercion
computeSCoercion: (_, SDyn()) -> SId()
computeSCoercion: (SDyn(), sft@FunTType(_, _, _, _)) -> SRuntimeCheck(sft)

// Add a cast after the current strategy (in sequence) if necessary to go from `from` to `to`
// Doesn't insert Cast(Id()). Adds error message when inserting Cast(Fail()).
insertCastAfter(|from, to) = insertCastAfter(|MTError(), from, to)
insertCastAfter(|lvl, from, to): strat -> strat'
  with
    c{t} := <computeCoercion(|lvl, from, to)> strat
  ; cast := Cast(c)
  ; strat' := <try(rm-redundant-cast)> Seq(strat, cast)

// Add a cast before the current strategy (in sequence) if necessary to go from `from` to `to`
// Doesn't insert Cast(Id()). Adds error message when inserting Cast(Fail()). 
insertCastBefore(|from, to) = insertCastBefore(|MTError(), from, to)
insertCastBefore(|lvl, from, to): strat -> strat'
  with
    c{t} := <computeCoercion(|lvl, from, to)> strat
  ; cast := Cast(c)
  ; strat' := <try(rm-redundant-cast)> Seq(cast, strat)

// Add a cast on the current term (the App or `<cast(to)> term`) if necessary to go from `from` to `to`
// Doesn't insert Cast(Id()). Adds error message when inserting Cast(Fail()). 
insertCastApp(|from, to) = insertCastApp(|MTError(), from, to)
insertCastApp(|lvl, from, to): (term1, st1) -> (term2, st2)
  with
    c{t} := <computeCoercion(|lvl, from, to)> term1
  ; cast := Cast(c)
  ; term2 := <try(rm-redundant-cast)> App(cast, term1)
  ; st2 := <current-type(|t)> st1

// Used to remove Id() casts
rm-redundant-cast: Seq(Cast(Id()), strat) -> strat
rm-redundant-cast: Seq(strat, Cast(Id())) -> strat
rm-redundant-cast: App(Cast(Id()), term) -> term

toBinding-DefHasType: DefHasType(name, stype) -> ((name{}, snum, tnum), stype')
  with
    stype' := <desugar-SType> stype
  ; (snum, tnum) := <arityOf-SType> stype'

toBinding-ExtSDef: d@ExtSDef(name, sargs, targs) ->
  ( (name{}, <length> sargs, <length> targs)
  , <otf(!FunTType(
      <map(otf(toBinding-ExtSDef-Typedid))> sargs
    , <map(otf(!DynT()))> targs
    , <otf(!DynT())> d
    , <otf(!DynT())> d))> d)
toBinding-ExtSDef-Typedid = ?VarDec(_, <toBinding-ExtSDef-ConstType + toBinding-ExtSDef-FunType>)
toBinding-ExtSDef-Typedid: DefaultVarDec(_) -> FunTType([], [], DynT(), DynT())
toBinding-ExtSDef-ConstType: ConstType(s) -> DynT()
toBinding-ExtSDef-FunType: FunType(a*, r) -> SDyn()

strategies // Messages

report-Err: (subj, msg) -> <rules(Message :+= (MTError(), (subj, msg)))>
report-Warn: (subj, msg) -> <rules(Message :+= (MTWarning(), (subj, msg)))>
report-Note: (subj, msg) -> <rules(Message :+= (MTNote(), (subj, msg)))>

report: (MTError(), subj, msg) -> <report-Err> (subj, msg)
report: (MTWarning(), subj, msg) -> <report-Warn> (subj, msg)
report: (MTNote(), subj, msg) -> <report-Note> (subj, msg)
report: (None(), subj, msg) -> <id> (subj, msg)

strategies // Helpers

getDefTypes =
  with(
      map(try(extToNormal))
    ; (haveTypes, defs) := <partition(nameOf-DefHasType)>
    ; defNames := <filter(nameOf-StrategyDef-RuleDef);imset-from-list> defs
      // detect duplicates in haveTypes => errors
    ; <foldl(getDefTypes-detect-duplicates)> (haveTypes, <imset-new>)
      // detect missing definitions for haveTypes => errors
    ; imset-subtract(|defNames)
    ; imset-map(where({?(name, _, _); <report-Err> (name, MissingDefinitionForTypeDefinition())}))
  )
  ; map(try(simpleDef))
  ; partition(toBinding-DefHasType, toBinding-ExtSDef)
  ; (immap-from-list, immap-from-list)
  ; immap-union(keep-left)

getDefTypes-detect-duplicates: (name-arity, set) -> <imset-insert(|name-arity)> set
  with if <imset-contains(|name-arity)> set
    then <report-Err> (<Fst> name-arity, DuplicateTypeDefinition())
  end

extToNormal: ExtSDefInl(n, s, t, b) -> SDefT(n, s, t, b)

simpleDef: ExtSDefInl(n, s, t, _) -> ExtSDef(n, s, t)
simpleDef: SDefT(n, s, t, _) -> ExtSDef(n, s, t)
simpleDef: SDef(n, s, _) -> ExtSDef(n, s, [])
simpleDef: SDefNoArgs(n, _) -> ExtSDef(n, [], [])
simpleDef: RDefT(n, s, t, _) -> ExtSDef(n, s, t)
simpleDef: RDef(n, s, _) -> ExtSDef(n, s, [])
simpleDef: RDefNoArgs(n, _) -> ExtSDef(n, [], [])

strategies

thread-map-reduce(s, reduce): ([], st) -> ([], st)
thread-map-reduce(s, reduce): (trm1*@[_ | _], st1) -> (trm2*, st2)
  where
    (trm2*, [st | st*]) := <unzip(\trm -> <s> (trm, st1)\)> trm1*
  ; st2 := <foldl(reduce)> (st*, st)

thread-map-LUB(s): ([], st) -> ([], [], st)
thread-map-LUB(s): (trm1*@[_ | _], st1) -> (trm2*, <reverse> t*, st2)
  where
    (trm2*, (st2, t*)) := <thread-map(thread-map-LUB-threader(s))> (trm1*, (st1, []))

thread-map-LUB-threader(s): (trm1, (st1, t1*)) -> (trm2, (st2, t2*))
  where
    (trm2, st2) := <s> (trm1, st1)
  ; t2* := [<current-type> st2 | t1*]

map-LUB(s): ([], st) -> ([], DynT(), st)
map-LUB(s): (trm1*@[_ | _], st1) -> (trm2*, t, st2)
  where
    (trm2*, [st | st*]) := <unzip(\trm -> <s> (trm, st1)\)> trm1*
  ; st2 := <foldl(st-merge(LUB <+ !DynT()))> (st*, st)
  ; t := <foldl(LUB <+ !DynT())> (st*, st)

map-st-LUB(s): ([], st) -> ([], [], st)
map-st-LUB(s): (trm1*@[_ | _], st1) -> (trm2*, t*, st2)
  where
    (trm2*, [st | st*]) := <unzip(\trm -> <s> (trm, st1)\)> trm1*
  ; st2 := <foldl(st-merge(LUB <+ !DynT()))> (st*, st)
  ; t* := <map(current-type)> [st | st*]

map-pair-left(|l) = map(split(!l, id))
map-pair-right(|r) = map(split(id, !r))

strategies

def-type-pair: DefHasType(name, t@FunNoArgsType(_, _)) -> ((name, 0, 0), <desugar-SType> t)
def-type-pair: DefHasType(name, t@FunType(sarg*, _, _)) -> ((name, <length> sarg*, 0), <desugar-SType> t)
def-type-pair: DefHasType(name, t@FunTType(sarg*, targ*, _, _)) ->
  ((name, <length> sarg*, <length> targ*), <desugar-SType> t)

strategies

extract-constr:
  OpDecl(c, ConstType(t1)) -> ((c,0), ConstrType([], t2))
  with t2 := <desugar-Type> t1

extract-constr:
  OpDeclQ(c, ConstType(t1)) -> ((c,0), ConstrType([], t2))
  with t2 := <desugar-Type> t1

extract-constr:
  OpDecl(c, FunType(t1*, ConstType(t1))) -> ((c, <length> t1*), ConstrType(t2*, t2))
  with
    t2 := <desugar-Type> t1
  ; t2* := <map(?ConstType(<desugar-Type>))> t1*

extract-constr:
  OpDeclQ(c, FunType(t1*, ConstType(t1))) -> ((c, <length> t1*), ConstrType(t2*, t2))
  with
    t2 := <desugar-Type> t1
  ; t2* := <map(?ConstType(<desugar-Type>))> t1*

extract-constr:
  OpDeclInj(FunType(t1*@[_, _ | _], ConstType(t1))) -> (("", <length> t1*), ConstrType(t2*, t2))
  with
    t2 := <desugar-Type> t1
  ; t2* := <map(?ConstType(<desugar-Type>))> t1*

// TODO: allow type definition?
extract-constr:
  OverlayNoArgs(c, _) -> ((c,0), ConstrType([], DynT()))

extract-constr:
  Overlay(c, t*, _) -> ((c, <length> t*), ConstrType(<map(!DynT())> t*, DynT()))

extract-constr:
  ExtOpDecl(c, ConstType(t1)) -> ((c,0), ConstrType([], t2))
  with t2 := <desugar-Type> t1

extract-constr:
  ExtOpDeclQ(c, ConstType(t1)) -> ((c,0), ConstrType([], t2))
  with t2 := <desugar-Type> t1

extract-constr:
  ExtOpDecl(c, FunType(t1*, ConstType(t1))) -> ((c, <length> t1*), ConstrType(t2*, t2))
  with
    t2 := <desugar-Type> t1
  ; t2* := <map(?ConstType(<desugar-Type>))> t1*

extract-constr:
  ExtOpDeclQ(c, FunType(t1*, ConstType(t1))) -> ((c, <length> t1*), ConstrType(t2*, t2))
  with
    t2 := <desugar-Type> t1
  ; t2* := <map(?ConstType(<desugar-Type>))> t1*

extract-constr:
  ExtOpDeclInj(FunType(t1*@[_, _ | _], ConstType(t1))) -> (("", <length> t1*), ConstrType(t2*, t2))
  with
    t2 := <desugar-Type> t1
  ; t2* := <map(?ConstType(<desugar-Type>))> t1*

extract-inj:
  OpDeclInj(FunType([ConstType(from)], ConstType(to))) -> (<desugar-Type> from, <desugar-Type> to)

extract-inj:
  ExtOpDeclInj(FunType([ConstType(from)], ConstType(to))) -> (<desugar-Type> from, <desugar-Type> to)
